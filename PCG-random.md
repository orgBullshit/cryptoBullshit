# [PCG, A Family of "Better" Random Number Generators](http://www.pcg-random.org/)

* __Misleading comparison:__ In the fancy table at the top of the index page, the PCG Family is always given a vague explanation and a green box for it's weak points, while competing algorithms are not given the same benefit.
* __Security theater:__ It labels the prediction difficulty as "challenging", even though it is a "medium quality" RNG passed through a hash function, by their own admission. This concept has been known to cryptographers for decades as "key stretching" - it does not make the output any less predictable, nor does it make a small key space any better. It just obfuscates the output slightly. Would you consider AES in CTR mode with a "medium quality" key to be a secure RNG? All you need to do to break the entire RNG, is to guess that key - but since you're running it through AES, statistical analysis will tell you it's high-quality output. Their prediction difficulty color should be changed from green to yellow.
* __Questionable claim:__ It claims that ChaCha20's space usage is 128 bytes, and that that is "plump". For a CSPRNG, that is impressive, not "plump".
* __Questionable claim:__ It claims ChaCha20's code is "complex". The [reference implementation](https://cr.yp.to/streamciphers/timings/estreambench/submissions/salsa20/chacha20/ref/chacha.c) is 114 lines and less than 3KB (including comments), it supports both 128-bit and 256-bit keys, and supports decryption. You could probably get it down to under 100 lines by ripping out the dead code, if you're using it for a CSPRNG (don't, though).
* __Questionable claim:__ It [states](http://www.pcg-random.org/other-rngs.html#id7) that ChaCha20 is "Slow, compared to general purpose generators". It's not at all slow compared to *cryptographically secure* generators; for comparison, Linux' `/dev/urandom` runs at about 20MB/s on a single thread of my i7 3930K. ChaCha20, however, takes [less than 2 CPU cycles per byte](https://bench.cr.yp.to/results-stream.html) on an Intel Core i5, or around 1.6GB/s on a single core. That's not slow, that's *ridiculously fast*, for a CSPRNG.
* __Misleading claim:__ The claim that "Multithreaded programs must share the global RNG, and contend for the spin lock that protects it" is a quirk of the OpenBSD kernel in general. The kernel is explicitly single-threaded, and to make it multi-threaded, locks would need to be implemented in many places - something nobody has bothered with yet. This is not the fault of the RNG, it's the fault of the kernel's current design.
* __Lack of theoretical understanding:__ They complain that OpenBSD's implementation of ChaCha20 as an RNG has "no facility for a user-provided seed, preventing programs from getting reproducible results". This is a design choice, and a good one at that. If you allow a user to explicitly seed the RNG, they will inevitably do something bad. At best, seeding it will do nothing - at worst, it'll make it completely predictable. If you need reproducible results, pre-generate random data.
* __Lack of theoretical understanding:__ It's "Provided as a single, global RNG". This is, again, a good design choice, as *anything* can use it. This even adds some more entropy, as you need to predict exactly how many bytes have been consumed by all the other running processes as well. As much as a single DNS packet you didn't account for, will make your predictions wrong.

__Conclusion:__ They're comparing apples (insecure RNGs) to oranges (cryptographically secure RNGs) whenever it suits them, to make their own product seem superior. This is sufficient reason to avoid it entirely.
